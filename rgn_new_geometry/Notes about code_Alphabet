Notes about code_Alphabet


First sanity check: generalize the code and check it works for the case of dihedrals

#86 alphabet is angularized, this condition needs to be relaxed if we include quaternions. Ask MAQ

#To call a variable from config in geomnet_model, e.g., max_length = config.optimization['num_steps'], 

#For batching #617, we use NUM_DIHEDRAL from inputs. Ask MAQ

Note: some functions (those without a preceding underscore), are defined in the file net_ops.py, e.g., read_protein

First step, reshape alphabet in #1131, ideally using a config option, such that we could easily switch between the different cases, N=2 (two dihedral), N=3 (three dihedral or Euler angles), or N=4 (quaternion components): DONE

Next steps, redifine the function _dihedrals such that we could account for different scenarios (dihedrals, Euler angles, quaternions, axis/angles etc.) I should call such function "charts" cf. Wikipedia or parametrizations: DONE

First, reshape output_size in #1151, again ideally by using config option: DONE

#1181 and #1185 needs to be changed to a more general function, instead of dihedrals and in linear in #1190

#1202 for now alphabet is angularized, to turn alphabet into angles (this should fine for Euler angles), for a more generic case, we should consider other function such as  normalize for quaternions, again by using a config option

#check #1212 for flatned angle mixtures, the definitions seem quite general

# 1214 if we average the outputs, we should consider a more general function, quaternion_average


To check if the function _weight is general to apply for the different cases

I could set dihedral to 2 and then consider the backbone case using Frenet frame, this might avoid the problem of omega (chirality). For reconstructing the backbone, I could imagine a function similar to MAQ.

I could first, turn the code into two dihedrals. I could have it as a config option (instead of seating omega to zero after prediction)


On geom_ops.py for consistency it seems that NUM_DIHEDRAL needs to be 3 see tf.multiply is #135-138. We could NUM_DIHEDRAL equal to three by imposing that the third dihedral, omega= 2\pi 


To choose between (i) angularize, (ii) normalize quaternions, etc. follow the example 'recurrent_unit':

for case in switch(config['recurrent_unit']):
            if case('LNLSTM'):
                recurrent_init = {'base': None, 'bias': None}
            elif case('CudnnLSTM') or case('CudnnGRU'):
                recurrent_init = {'base': dict_to_init({}), 'bias': None}
            else:
                recurrent_init = {'base': None, 'bias': tf.zeros_initializer()}
